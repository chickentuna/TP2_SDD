\documentclass[a4paper,11pt] {article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{verbatim}
\usepackage{graphicx}

\title{Rapport TD de Structure}
\author{Julien Poulton & Peluso Loup}
\date{17/03/2012}

\begin{document}

\part{Présentation du projet}

  L'objectif de ce TP est de coder un système capable de gérer et de parcourir des arborescences structurées par lien vertical et horizontal. La structure de donnée sera codée en \verb?C? et le code contiendra les fonctions de recherche et suppression (avec élagage), ainsi que la possibilité de charger un arbre en mémoire à partir de son écriture algébrique dans un fichier. Le code pourra aussi afficher à l'écran le nombre de nœuds, le nombre de feuilles, et la hauteur d'un arbre.

\section{Description du projet}

\subsection{Schéma de la structure de donnée}

Chaque nœud d'un arbre est représenté par un mot de 3 bloc. Ce bloc contient :

\vspace{0.5cm}
	
\begin{itemize}
\item La valeur du nœud (ici, un seul caractère).
\item Le lien horizontal du nœud, c'est à dire un pointeur vers son frère suivant (s'il en a un).
\item Le lien vertical du nœud, c'est à dire un pointeur vers son premier fils (s'il en a).
\end{itemize}

\vspace{0.5cm}

Le premier nœud est appelé \emph{racine} de l'arbre.\\

Le parcours d'un arbre se fait grâce à une pile. Une pile est par un tableau d'éléments dont un désigné comme étant la tête. L'indice de l'élément de tête est stockée en mémoire.\\
%TODO peut-être qu'il faudrait plus approfondir la pile

Dans le code, les piles et les arborescences utilisées sont des \verb#struct#s. De plus, les éléments de la pile sont déclarés avec un \verb#typedef# afin d'en garantir la généricité.
%
% et sont, par défaut, des \verb#void*#. (What the fuck ? j'ai pas compris en quoi les typedef sont des void* ?)
%
Quant au valeur des nœuds d'un arbre, ce sont des \verb?char?.
%
% (cf. DDD_arbre_exemple.png). (je sais pas pourquoi ça bug...
% J'ai été obligé de commenter.
\subsection{Organisation du code source}

Le code source est divisé en trois parties : Le noyau (toutes les fonctions répondant au besoins du TP), la section \og tests\fg\ pour les fonctions de test, le système de gestion des tests (indépendant du TP), et enfin le programme principal, \verb#main.c#, contenant la fonction \verb#main()# qui charge un fichier dont le nom est donné en ligne de commande et affiche la structure de donnée générée. Le fichier doit contenir la notation algébrique d'un arbre avec un seul caractère par élément.\\

Une exécution du programme avec le fichier \verb#exemple.arbre# vu par \verb?ddd? est donné en annexe, ainsi que son rapport \verb?valgrind?.

dans \verb#main.c#, qui permet soit d'exécuter les tests de toutes les fonctions du noyau, soit de charger un fichier à traiter (le nom du fichier doit être donné en commande).\\

Les macros et types généraux sont déclarés dans \verb#lib.h#.\\

Les fonctions relatives à la pile sont codés dans \verb#pile.c#.

\vspace{0.5cm}

\begin{itemize}
	\item \verb#initPile()#
	\item \verb#empiler()#
	\item \verb#depiler()#
	\item \verb#vide()#
	\item \verb#pleine()#
	\item \verb#libererPile()#
\end{itemize}

\vspace{0.5cm}

Les fonctions relatives aux arbres sont codées dans \verb#arbre.c#.

\vspace{0.5cm}

\begin{itemize}
    \item \verb#initArbre()#
    \item \verb#arbreSupprimer()#
    \item \verb#arbreSupprimerValeur()#
    \item \verb#arbreRecherche()#
    \item \verb#compterNoeuds()#
    \item \verb#mesurerHauteur()#
    \item \verb#compterFeuilles()#
    \item \verb#libererArbre()#
\end{itemize}

\vspace{0.5cm}

La fonction \verb#initArbre()# utilise trois sous-programmes : 

\vspace{0.5cm}

\begin{itemize}
    \item \verb#obtenirValeur()#
    \item \verb#obtenirOperation()#
    \item \verb#obtenirSuivant()#
\end{itemize}

\vspace{0.5cm}

La documentation des ces fonctions se trouve respectivement dans \verb#pile.h# et \verb#arbre.h#. Ces fichiers contiennent aussi des fonctions \verb#toString()# pour convertir les structures de données associées en chaine de caractères, utilisées uniquement par le système de test.\\

Les fonctions qui gèrent l'exécution et l'affichage des sorties des test sont déclarées dans \verb#testlib.h# et codées dans \verb#testlib.c#.\\

Chaque fonction du noyau est testée individuellement dans \verb#tests.c# selon le principe des tests unitaires (c'est-à-dire que chaque fonction est testée dans un contexte qui lui est propre). La liste des tests à exécuter est déclarée dans \verb#tests.h#.\\

Pour lancer les tests, ajoutez \verb#test# à la ligne d'exécution du programme.\\

Le résultat d'une exécution de ces tests est donné en annexe, ainsi que son rapport \verb?valgrind?.\\

\section{Méthodologie}
\subsection{Langage de programmation}
Il était imposé d'utiliser le langage C dans le cadre de ce TD.
\subsection{Gestionnaire de version}
Afin de pouvoir travailler à deux simplement nous avons décidé d'utiliser le gestionnaire de version GIT ainsi que GitHub.com pour centraliser le code.

\end{document}

% Franchement, bravo pour ce compte rendu. Beau travail. J'ai corrigé quelques faute et l'encodage aussi.